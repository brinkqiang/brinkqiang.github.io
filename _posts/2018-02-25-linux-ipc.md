---
title: linux-ipc
description:
categories:
 - linux-ipc
tags:
---

# 1. 共享内存
现代Linux有两种共享内存机制：

POSIX共享内存（shm_open()、shm_unlink()）
System V共享内存（shmget()、shmat()、shmdt()）
其中，System V共享内存历史悠久，一般的UNIX系统上都有这套机制；而POSIX共享内存机制接口更加方便易使用，一般是结合内存映射mmap用。

mmap和System V共享内存的主要区别在于：
sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；
mmap映射的内存在不是持久化的，假如进程关闭，映射随即失效，除非事前已经映射到了一个文件上。
内存映射机制mmap是POSIX标准的系统调使用，有匿名映射和文件映射两种。

匿名映射用进程的虚拟内存空间，它和malloc(3)相似，实际上有些malloc实现会用mmap匿名映射分配内存，不过匿名映射不是POSIX标准中规定的。
文件映射有MAP_PRIVATE和MAP_SHARED两种。前者用COW的方式，把文件映射到当前的进程空间，修改操作不会改动源文件。后者直接把文件映射到当前的进程空间，所有的修改会直接反应到文件的page cache，而后由内核自动同步到映射文件上。

相比于IO函数调使用，基于文件的mmap的一大优点是把文件映射到进程的地址空间，避免了数据从使用户缓冲区到内核page cache缓冲区的复制过程；当然还有一个优点就是不需要频繁的read/write系统调使用。

因为接口易使用，且可以方便的persist到文件，避免主机shutdown丢失数据的情况，所以在现代操作系统上一般偏向于用mmap而不是传统的System V的共享内存机制。

建议仅把mmap使用于需要大量内存数据操作的场景，而不使用于IPC。由于IPC总是在多个进程之间通信，而通信则涉及到同步问题，假如自己手工在mmap之上实现同步，容易滋生bug。推荐用socket之类的机制做IPC，基于socket的通信机制相对健全很多，有很多成熟的机制和模式，比方epoll, reactor等。

sysv shm的实现可以参考glibc源码，shm_open(3) 打开一个名为abc的共享内存，等价于open("/dev/shm/abc", ..)，其中 /dev/shm 是Linux下sysv共享内存的默认挂载点。shm_open调使用返回一个文件形容符，其实也可以给 mmap(2) 用，作为named share memory用。

第一种：mmap方式，适用场景：父子进程之间，创建的内存非常大时
第二种：shmget方式，适用场景：同一台电脑上不同进程之间，创建的内存相对较小时
