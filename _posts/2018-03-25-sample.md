---
title: 案例
description:
categories:
 - sample
tags:
---

- 关注的点: 实体, 抽象, 推理, 总结

# 1. 实体事物理解

## 1.1. 网络引擎

### 1.1.1. 优化点. 网络引擎性能本质点在网络事件处理单帧所耗时间

## 1.2. 时钟层面

### 1.2.1. 使用精度与预计精度的统一, 精度分级.  

### 1.2.2. 影响时钟性能的因素, 所使用的数据结构, 所使用的时间API的精度.  

### 1.2.3. 时钟的实现让我理解了分时, 从而在多线程问题上没有再犯过错误.  

## 1.3. 脚本层面

### 1.3.1. 脚本负责 会经常变化的逻辑.

### 1.3.2. lua只负责调用, 不使用本身lua的数据结构(为了解决lua reload数据归属问题).

## 1.4. 数据库层面

### 1.4.1. dmsql 负责具体SQL语句的生成

### 1.4.2. dmsqldiff 负责数据库的库创建, 表创建, 表字段变更.

### 1.4.3. 多线程问题

## 1.5. 内存层面

### 1.5.1. 内存泄露认知 (一次性泄漏 , 常规性泄漏 , 偶发性泄漏 , 运行时泄漏)  

### 1.5.2. 使用内存池解决内存碎片问题(问题点: 内存池 没有对象类型信息), 使用对象池解决内存泄漏问题(管理需要管理的内存). 

### 1.5.3. 内存分配失败默认处理

### 1.5.4. 可以用工具检测出来的内存泄漏不是内存泄露, 即我们主要要解决的内存泄漏是: 运行时泄漏  

## 1.6. 多线程层面

### 1.6.1. io, 操作无关, 高耗, 低锁  使用线程效率较高.

### 1.6.2. 设计上规避多读多写.  

### 1.6.3. 积极使用无锁队列.  

### 1.6.4. 多线程的精髓为分时 理解了分时就理解了多线程.

## 1.7. 日志

### 1.7.1. debug不能解决所有问题, 但是日志可以.  

### 1.7.2. 日志的写入应该是同步的, 日志分级, 分文件.  

### 1.7.3. 根据项目情况选择合适的日志组件.(glog让我明白 从设计上解决问题的重要性)  


# 2. 抽象

## 2.1. C++学习历程
LEVEL1 C++ 不好(内容太多)  
LEVEL2 C++ 好(使用方便)  
LEVEL3 C++ 不好(细节太多 容易出错)  
LEVEL4 C++ 好(掌握细节)  
LEVEL5 C++ 不好(效率太差)  
LEVEL6 C++ 好(选择性的使用)  
LEVEL7 C++ 不好(C的回归)  

## 2.2. 理解的角度
观察 (细节)  
看 (大局)  
感受 (发现规律)  
洞见 (点爆发)  
所谓理解就是要理解模式  

## 2.3. 问题理解层级
(1) 发现问题  
(2) 解决问题  
(3) 规避问题  
(4) 消灭问题  
(5) 创造问题  

## 2.4. 问题规避原则
(1) 设计上规避(例如: glog在设计上面使用多线程独立文件来规避单文件加锁问题)  
(2) 约定规避(例如: 约定使用int64放大若干倍数来替代浮点数)  
(3) 实现规避(例如: 在高性能要求的场景, 使用纯C的数据结构来替代复杂的C++数据结构)  
(4) 潜规则规避(例如: 利用平台语言或者数据结构的特性 来规避问题)  

## 2.5. 如何消灭问题
(1) 编码规范  
(2) 数据驱动开发  
(3) 代码生成技术  
(4) 为什么消灭了问题? 人是最不可控的, 减少了人本身对事物的影响.  

# 3. 编程感悟
程序的精髓在于数据结构的组织与控制.  
稳定的需求是产品质量的基石.  
真正的需求，潜藏在人性因素与其他一系列因素的相互关联之中.  