---
title: 案例
description:
categories:
 - sample
tags:
---

- 关注的点: 实体, 抽象, 推理, 总结
<!-- TOC -->

- [1. 实体事物理解](#1-%E5%AE%9E%E4%BD%93%E4%BA%8B%E7%89%A9%E7%90%86%E8%A7%A3)
    - [1.1. 网络引擎](#11-%E7%BD%91%E7%BB%9C%E5%BC%95%E6%93%8E)
        - [1.1.1. 优化点. 网络引擎性能本质点在网络事件处理单帧所耗时间](#111-%E4%BC%98%E5%8C%96%E7%82%B9-%E7%BD%91%E7%BB%9C%E5%BC%95%E6%93%8E%E6%80%A7%E8%83%BD%E6%9C%AC%E8%B4%A8%E7%82%B9%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%8D%95%E5%B8%A7%E6%89%80%E8%80%97%E6%97%B6%E9%97%B4)
        - [1.1.2. 服务器引擎速度较低 20W QPS, 经过优化达到单链接40W QPS, 多链接 70W QPS.](#112-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%95%E6%93%8E%E9%80%9F%E5%BA%A6%E8%BE%83%E4%BD%8E-20w-qps-%E7%BB%8F%E8%BF%87%E4%BC%98%E5%8C%96%E8%BE%BE%E5%88%B0%E5%8D%95%E9%93%BE%E6%8E%A540w-qps-%E5%A4%9A%E9%93%BE%E6%8E%A5-70w-qps)
    - [1.2. 时钟层面](#12-%E6%97%B6%E9%92%9F%E5%B1%82%E9%9D%A2)
        - [1.2.1. 使用精度与预计精度的统一, 精度分级.](#121-%E4%BD%BF%E7%94%A8%E7%B2%BE%E5%BA%A6%E4%B8%8E%E9%A2%84%E8%AE%A1%E7%B2%BE%E5%BA%A6%E7%9A%84%E7%BB%9F%E4%B8%80-%E7%B2%BE%E5%BA%A6%E5%88%86%E7%BA%A7)
        - [1.2.2. 影响时钟性能的因素, 所使用的数据结构, 所使用的时间API的精度.](#122-%E5%BD%B1%E5%93%8D%E6%97%B6%E9%92%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0-%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4api%E7%9A%84%E7%B2%BE%E5%BA%A6)
        - [1.2.3. 时钟的实现让我理解了分时, 从而在多线程问题上没有再犯过错误.](#123-%E6%97%B6%E9%92%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%AE%A9%E6%88%91%E7%90%86%E8%A7%A3%E4%BA%86%E5%88%86%E6%97%B6-%E4%BB%8E%E8%80%8C%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8A%E6%B2%A1%E6%9C%89%E5%86%8D%E7%8A%AF%E8%BF%87%E9%94%99%E8%AF%AF)
        - [1.2.4. 在C++领域有大量不同实现方法的定时器组件. 在使用上面 要么在性能上面非常差, 要么易用性上面非常差.](#124-%E5%9C%A8c%E9%A2%86%E5%9F%9F%E6%9C%89%E5%A4%A7%E9%87%8F%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E7%BB%84%E4%BB%B6-%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2-%E8%A6%81%E4%B9%88%E5%9C%A8%E6%80%A7%E8%83%BD%E4%B8%8A%E9%9D%A2%E9%9D%9E%E5%B8%B8%E5%B7%AE-%E8%A6%81%E4%B9%88%E6%98%93%E7%94%A8%E6%80%A7%E4%B8%8A%E9%9D%A2%E9%9D%9E%E5%B8%B8%E5%B7%AE)
        - [1.2.5. 很多定时器的之间性能差距能达到100+倍. 汇总各个定时器实现之优劣,  综合应用领域易用性优先原则.](#125-%E5%BE%88%E5%A4%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%B9%8B%E9%97%B4%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D%E8%83%BD%E8%BE%BE%E5%88%B0100%E5%80%8D-%E6%B1%87%E6%80%BB%E5%90%84%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%BC%98%E5%8A%A3--%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E6%98%93%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E5%8E%9F%E5%88%99)
        - [1.2.6. 定时器的使用上面有很多需要注意的细节, 导致各种诡异bug. 通过对定时器各种实现的理解. 总结出如何规避这些问题.](#126-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2%E6%9C%89%E5%BE%88%E5%A4%9A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82-%E5%AF%BC%E8%87%B4%E5%90%84%E7%A7%8D%E8%AF%A1%E5%BC%82bug-%E9%80%9A%E8%BF%87%E5%AF%B9%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%90%86%E8%A7%A3-%E6%80%BB%E7%BB%93%E5%87%BA%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BF%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98)
        - [1.2.7. 基础定时器功能实现, 指定触发时间间隔, 触发回调](#127-%E5%9F%BA%E7%A1%80%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0-%E6%8C%87%E5%AE%9A%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94-%E8%A7%A6%E5%8F%91%E5%9B%9E%E8%B0%83)
        - [1.2.8. 可指定第一次触发时间间隔](#128-%E5%8F%AF%E6%8C%87%E5%AE%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%A6%E5%8F%91%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94)
        - [1.2.9. 动态绑定参数, 及回调实现](#129-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0-%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0)
        - [1.2.10. 可指定调用策略, 漏调补调模式](#1210-%E5%8F%AF%E6%8C%87%E5%AE%9A%E8%B0%83%E7%94%A8%E7%AD%96%E7%95%A5-%E6%BC%8F%E8%B0%83%E8%A1%A5%E8%B0%83%E6%A8%A1%E5%BC%8F)
        - [1.2.11. 安全移除定时器](#1211-%E5%AE%89%E5%85%A8%E7%A7%BB%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8)
        - [1.2.12. 增加获取定时器已执行时间, 下一次执行时间间隔接口](#1212-%E5%A2%9E%E5%8A%A0%E8%8E%B7%E5%8F%96%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%B2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4-%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E6%8E%A5%E5%8F%A3)
        - [1.2.13. 实现高性能对象池, 解决性能热点](#1213-%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%AF%B9%E8%B1%A1%E6%B1%A0-%E8%A7%A3%E5%86%B3%E6%80%A7%E8%83%BD%E7%83%AD%E7%82%B9)
        - [1.2.14. 调试导致时间异常处理](#1214-%E8%B0%83%E8%AF%95%E5%AF%BC%E8%87%B4%E6%97%B6%E9%97%B4%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86)
        - [1.2.15. 系统时间调整无关性处理](#1215-%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4%E6%97%A0%E5%85%B3%E6%80%A7%E5%A4%84%E7%90%86)
        - [1.2.16. 支持 windows, linux, mac平台](#1216-%E6%94%AF%E6%8C%81-windows-linux-mac%E5%B9%B3%E5%8F%B0)
        - [1.2.17. 支持对象内存搬移, 鉴于使用中需要注意事项较多, 不推荐使用.](#1217-%E6%94%AF%E6%8C%81%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%90%AC%E7%A7%BB-%E9%89%B4%E4%BA%8E%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E8%BE%83%E5%A4%9A-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8)
    - [1.3. 脚本层面](#13-%E8%84%9A%E6%9C%AC%E5%B1%82%E9%9D%A2)
        - [1.3.1. 脚本负责 会经常变化的逻辑.](#131-%E8%84%9A%E6%9C%AC%E8%B4%9F%E8%B4%A3-%E4%BC%9A%E7%BB%8F%E5%B8%B8%E5%8F%98%E5%8C%96%E7%9A%84%E9%80%BB%E8%BE%91)
        - [1.3.2. 自动枚举目录下所有lua脚本预加载, 脚本正确性检测](#132-%E8%87%AA%E5%8A%A8%E6%9E%9A%E4%B8%BE%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89lua%E8%84%9A%E6%9C%AC%E9%A2%84%E5%8A%A0%E8%BD%BD-%E8%84%9A%E6%9C%AC%E6%AD%A3%E7%A1%AE%E6%80%A7%E6%A3%80%E6%B5%8B)
        - [1.3.3. 自动化导出C++数据结构](#133-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AF%BC%E5%87%BAc%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
        - [1.3.4. C++ call lua的参数及返回值模板化实现自动化绑定](#134-c-call-lua%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%91%E5%AE%9A)
        - [1.3.5. 支持直接热更, 以及热更失败相关处理逻辑](#135-%E6%94%AF%E6%8C%81%E7%9B%B4%E6%8E%A5%E7%83%AD%E6%9B%B4-%E4%BB%A5%E5%8F%8A%E7%83%AD%E6%9B%B4%E5%A4%B1%E8%B4%A5%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91)
        - [1.3.6. 支持lua5.3版本](#136-%E6%94%AF%E6%8C%81lua53%E7%89%88%E6%9C%AC)
        - [1.3.7. 支持 windows, linux, mac平台](#137-%E6%94%AF%E6%8C%81-windows-linux-mac%E5%B9%B3%E5%8F%B0)
        - [1.3.8. 本引擎实现 建议只是建议, 如果必须要使用, 需要使用者自己处理 下述问题使用者 规避在lua中定义lua的动态数据结构 以避免 脚本reload数据归属权不明确问题.](#138-%E6%9C%AC%E5%BC%95%E6%93%8E%E5%AE%9E%E7%8E%B0-%E5%BB%BA%E8%AE%AE%E5%8F%AA%E6%98%AF%E5%BB%BA%E8%AE%AE-%E5%A6%82%E6%9E%9C%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BD%BF%E7%94%A8-%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E8%80%85%E8%87%AA%E5%B7%B1%E5%A4%84%E7%90%86-%E4%B8%8B%E8%BF%B0%E9%97%AE%E9%A2%98%E4%BD%BF%E7%94%A8%E8%80%85-%E8%A7%84%E9%81%BF%E5%9C%A8lua%E4%B8%AD%E5%AE%9A%E4%B9%89lua%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BB%A5%E9%81%BF%E5%85%8D-%E8%84%9A%E6%9C%ACreload%E6%95%B0%E6%8D%AE%E5%BD%92%E5%B1%9E%E6%9D%83%E4%B8%8D%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98)
    - [1.4. 数据库层面](#14-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2)
        - [1.4.1. dmsql 负责具体SQL语句的生成](#141-dmsql-%E8%B4%9F%E8%B4%A3%E5%85%B7%E4%BD%93sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%9F%E6%88%90)
        - [1.4.2. dmsqldiff 负责数据库的库创建, 表创建, 表字段变更.](#142-dmsqldiff-%E8%B4%9F%E8%B4%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%BA%93%E5%88%9B%E5%BB%BA-%E8%A1%A8%E5%88%9B%E5%BB%BA-%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%8F%98%E6%9B%B4)
        - [1.4.3. 多线程问题, command对象释放问题](#143-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98-command%E5%AF%B9%E8%B1%A1%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98)
    - [1.5. 内存层面](#15-%E5%86%85%E5%AD%98%E5%B1%82%E9%9D%A2)
        - [1.5.1. 内存泄露认知 一次性泄漏 , 常规性泄漏 , 偶发性泄漏 , 运行时泄漏](#151-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E8%AE%A4%E7%9F%A5-%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B3%84%E6%BC%8F--%E5%B8%B8%E8%A7%84%E6%80%A7%E6%B3%84%E6%BC%8F--%E5%81%B6%E5%8F%91%E6%80%A7%E6%B3%84%E6%BC%8F--%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%84%E6%BC%8F)
        - [1.5.2. 使用内存池解决内存碎片问题问题点: 内存池 没有对象类型信息, 使用对象池解决内存泄漏问题管理需要管理的内存.](#152-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%B1%A0%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%E9%97%AE%E9%A2%98%E7%82%B9-%E5%86%85%E5%AD%98%E6%B1%A0-%E6%B2%A1%E6%9C%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E7%AE%A1%E7%90%86%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E5%AD%98)
        - [1.5.3. 内存分配失败默认处理](#153-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86)
        - [1.5.4. 可以用工具检测出来的内存泄漏不是内存泄露, 即我们主要要解决的内存泄漏是: 运行时泄漏](#154-%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B%E5%87%BA%E6%9D%A5%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8D%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%8D%B3%E6%88%91%E4%BB%AC%E4%B8%BB%E8%A6%81%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%84%E6%BC%8F)
        - [1.5.5. 案例: 某次服务器存在内存泄漏, 我们通过打印对象池 发现 某个对象数量非常. 经过排查, 发现在某些条件下 释放存在问题.](#155-%E6%A1%88%E4%BE%8B-%E6%9F%90%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E6%89%93%E5%8D%B0%E5%AF%B9%E8%B1%A1%E6%B1%A0-%E5%8F%91%E7%8E%B0-%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F%E9%9D%9E%E5%B8%B8-%E7%BB%8F%E8%BF%87%E6%8E%92%E6%9F%A5-%E5%8F%91%E7%8E%B0%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%9D%A1%E4%BB%B6%E4%B8%8B-%E9%87%8A%E6%94%BE%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98)
    - [1.6. 多线程层面](#16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B1%82%E9%9D%A2)
        - [1.6.1. io, 操作无关, 高耗, 低锁  使用线程效率较高.](#161-io-%E6%93%8D%E4%BD%9C%E6%97%A0%E5%85%B3-%E9%AB%98%E8%80%97-%E4%BD%8E%E9%94%81--%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%95%88%E7%8E%87%E8%BE%83%E9%AB%98)
        - [1.6.2. 设计上规避多读多写.](#162-%E8%AE%BE%E8%AE%A1%E4%B8%8A%E8%A7%84%E9%81%BF%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99)
        - [1.6.3. 积极使用无锁队列.](#163-%E7%A7%AF%E6%9E%81%E4%BD%BF%E7%94%A8%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97)
        - [1.6.4. 多线程的精髓为分时 理解了分时就理解了多线程.](#164-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%B2%BE%E9%AB%93%E4%B8%BA%E5%88%86%E6%97%B6-%E7%90%86%E8%A7%A3%E4%BA%86%E5%88%86%E6%97%B6%E5%B0%B1%E7%90%86%E8%A7%A3%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B)
    - [1.7. 日志](#17-%E6%97%A5%E5%BF%97)
        - [1.7.1. debug不能解决所有问题, 但是日志可以.](#171-debug%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98-%E4%BD%86%E6%98%AF%E6%97%A5%E5%BF%97%E5%8F%AF%E4%BB%A5)
        - [1.7.2. 日志的写入应该是同步的, 日志分级, 分文件.](#172-%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E5%BA%94%E8%AF%A5%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84-%E6%97%A5%E5%BF%97%E5%88%86%E7%BA%A7-%E5%88%86%E6%96%87%E4%BB%B6)
        - [1.7.3. 根据项目情况选择合适的日志组件. glog让我明白 从设计上解决问题的重要性](#173-%E6%A0%B9%E6%8D%AE%E9%A1%B9%E7%9B%AE%E6%83%85%E5%86%B5%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%97%A5%E5%BF%97%E7%BB%84%E4%BB%B6-glog%E8%AE%A9%E6%88%91%E6%98%8E%E7%99%BD-%E4%BB%8E%E8%AE%BE%E8%AE%A1%E4%B8%8A%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
- [2. 抽象](#2-%E6%8A%BD%E8%B1%A1)
    - [2.1. C++学习历程](#21-c%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B)
    - [2.2. 理解的角度](#22-%E7%90%86%E8%A7%A3%E7%9A%84%E8%A7%92%E5%BA%A6)
    - [2.3. 问题理解层级](#23-%E9%97%AE%E9%A2%98%E7%90%86%E8%A7%A3%E5%B1%82%E7%BA%A7)
    - [2.4. 问题规避原则](#24-%E9%97%AE%E9%A2%98%E8%A7%84%E9%81%BF%E5%8E%9F%E5%88%99)
    - [2.5. 如何消灭问题](#25-%E5%A6%82%E4%BD%95%E6%B6%88%E7%81%AD%E9%97%AE%E9%A2%98)
- [3. 编程感悟](#3-%E7%BC%96%E7%A8%8B%E6%84%9F%E6%82%9F)

<!-- /TOC -->

# 1. 实体事物理解

## 1.1. 网络引擎

### 1.1.1. 优化点. 网络引擎性能本质点在网络事件处理单帧所耗时间

### 1.1.2. 服务器引擎速度较低 20W QPS, 经过优化达到单链接40W QPS, 多链接 70W QPS.

## 1.2. 时钟层面

### 1.2.1. 使用精度与预计精度的统一, 精度分级.  

### 1.2.2. 影响时钟性能的因素, 所使用的数据结构, 所使用的时间API的精度.  

### 1.2.3. 时钟的实现让我理解了分时, 从而在多线程问题上没有再犯过错误. 

### 1.2.4. 在C++领域有大量不同实现方法的定时器组件. 在使用上面 要么在性能上面非常差, 要么易用性上面非常差.

### 1.2.5. 很多定时器的之间性能差距能达到100+倍. 汇总各个定时器实现之优劣,  综合应用领域易用性优先原则.

### 1.2.6. 定时器的使用上面有很多需要注意的细节, 导致各种诡异bug. 通过对定时器各种实现的理解. 总结出如何规避这些问题.

### 1.2.7. 基础定时器功能实现, 指定触发时间间隔, 触发回调

### 1.2.8. 可指定第一次触发时间间隔

### 1.2.9. 动态绑定参数, 及回调实现

### 1.2.10. 可指定调用策略, 漏调补调模式

### 1.2.11. 安全移除定时器

### 1.2.12. 增加获取定时器已执行时间, 下一次执行时间间隔接口

### 1.2.13. 实现高性能对象池, 解决性能热点

### 1.2.14. 调试导致时间异常处理

### 1.2.15. 系统时间调整无关性处理

### 1.2.16. 支持 windows, linux, mac平台

### 1.2.17. 支持对象内存搬移, 鉴于使用中需要注意事项较多, 不推荐使用.

## 1.3. 脚本层面

### 1.3.1. 脚本负责 会经常变化的逻辑.

### 1.3.2. 自动枚举目录下所有lua脚本预加载, 脚本正确性检测

### 1.3.3. 自动化导出C++数据结构

### 1.3.4. C++ call lua的参数及返回值模板化实现自动化绑定

### 1.3.5. 支持直接热更, 以及热更失败相关处理逻辑

### 1.3.6. 支持lua5.3版本

### 1.3.7. 支持 windows, linux, mac平台

### 1.3.8. 本引擎实现 建议(只是建议, 如果必须要使用, 需要使用者自己处理 下述问题)使用者 规避在lua中定义lua的动态数据结构 以避免 脚本reload数据归属权不明确问题.

## 1.4. 数据库层面

### 1.4.1. dmsql 负责具体SQL语句的生成

### 1.4.2. dmsqldiff 负责数据库的库创建, 表创建, 表字段变更.

### 1.4.3. 多线程问题, command对象释放问题

## 1.5. 内存层面

### 1.5.1. 内存泄露认知 (一次性泄漏 , 常规性泄漏 , 偶发性泄漏 , 运行时泄漏)  

### 1.5.2. 使用内存池解决内存碎片问题(问题点: 内存池 没有对象类型信息), 使用对象池解决内存泄漏问题(管理需要管理的内存). 

### 1.5.3. 内存分配失败默认处理

### 1.5.4. 可以用工具检测出来的内存泄漏不是内存泄露, 即我们主要要解决的内存泄漏是: 运行时泄漏  

### 1.5.5. 案例: 某次服务器存在内存泄漏, 我们通过打印对象池 发现 某个对象数量非常多. 经过排查, 发现在某些条件下 释放存在问题.

## 1.6. 多线程层面

### 1.6.1. io, 操作无关, 高耗, 低锁  使用线程效率较高.

### 1.6.2. 设计上规避多读多写.  

### 1.6.3. 积极使用无锁队列.  

### 1.6.4. 多线程的精髓为分时 理解了分时就理解了多线程.

## 1.7. 日志

### 1.7.1. debug不能解决所有问题, 但是日志可以.  

### 1.7.2. 日志的写入应该是同步的, 日志分级, 分文件.  

### 1.7.3. 根据项目情况选择合适的日志组件. (glog让我明白 从设计上解决问题的重要性)  

# 2. 业务层面思考

## 2.1. 对象数据结构组织与控制以及对象生命周期管理

# 3. 抽象

## 3.1. C++学习历程

- C++ 学习曲线:  
LEVEL1 C++ 不好(内容太多)  
LEVEL2 C++ 好(使用方便)  
LEVEL3 C++ 不好(细节太多 容易出错)  
LEVEL4 C++ 好(掌握细节)  
LEVEL5 C++ 不好(效率太差)  
LEVEL6 C++ 好(选择性的使用)  
LEVEL7 C++ 不好(C的回归)  

- C++ 学习路径:  
Level 1: C++ 初学者
评判标准: 了解 C++ 基本语法，能够编写简单的程序，例如控制台输出、变量使用、简单运算等。
用例: 编写简单的 “Hello World” 程序，进行基础的数值计算。
Level 2: C++ 熟练者
评判标准: 掌握 C++ 核心语法，熟悉常用数据结构和算法，能够编写结构化的程序，例如分支、循环、函数等。
用例: 实现简单的排序算法，编写学生管理系统等小型程序。
Level 3: C++ 应用者
评判标准: 理解面向对象编程 (OOP) 的概念，能够使用类、继承、多态等特性，编写面向对象的程序。
用例: 设计并实现简单的游戏，开发图形界面应用程序。
Level 4: C++ 专家
评判标准: 掌握 C++ 高级特性，例如模板、异常处理、运算符重载等，能够编写高质量、可复用的代码。
用例: 开发高性能库或框架，设计并实现复杂的数据结构和算法。
Level 5: C++ 大师
评判标准: 深入理解 C++ 内存管理机制，能够进行底层优化，编写高性能、高效的代码。
用例: 开发实时系统、高并发应用，对现有代码进行性能分析和优化。
Level 6: C++ 架构师
评判标准: 能够根据需求选择合适的 C++ 特性，设计并实现大型软件架构，并能进行跨平台开发。
用例: 设计并实现分布式系统、云平台等复杂软件项目。
Level 7: C++ 悟道者
评判标准:
对 C++ 有着深刻的理解，洞悉其设计哲学和发展历程。
能够灵活运用 C++ 和 C，根据项目需求选择最佳方案。
积极参与 C++ 社区，推动 C++ 语言的发展。
用例:
编写高性能、可移植的库或框架。
参与 C++ 标准制定或开源项目贡献。
指导和培养下一代 C++ 开发者。

- C++ 学习方式:
自学: 通过书籍、在线课程、教程等资源进行自主学习。
学校教育: 在大学或培训机构接受系统性的 C++ 教育。
实践项目: 通过参与实际项目，在实践中学习和提升 C++ 技能。
社区交流: 加入 C++ 社区，与其他开发者交流学习经验，互相帮助。
- C++ 学习内容:
语言基础: 语法、数据类型、运算符、控制流等。
标准库 (STL): 容器、算法、迭代器等。
面向对象编程 (OOP): 类、继承、多态、封装等。
模板: 函数模板、类模板、模板元编程等。
内存管理: 指针、动态内存分配、智能指针等。
异常处理: try-catch-throw 机制，异常安全等。
并发编程: 线程、互斥锁、原子操作等。
网络编程: Socket 编程、网络协议等。
图形界面编程: 使用 Qt、wxWidgets 等库进行图形界面开发。
- C++ 学习目标:
兴趣爱好: 出于对编程的热爱，想要学习 C++ 并探索其可能性。
职业发展: 希望成为 C++ 开发工程师，从事相关领域的软件开发工作。
学术研究: 进行 C++ 相关的学术研究，例如编译器开发、语言设计等。
- C++ 学习挑战:
C++ 语言本身的复杂性: C++ 语法庞大，特性繁多，学习曲线陡峭。
内存管理的难度: 手动管理内存容易出错，需要开发者具备较强的责任心和调试能力。
新标准的不断更新: C++ 标准不断演进，开发者需要持续学习新特性。
- C++ 学习建议:
循序渐进，打好基础: 从基础语法开始，逐步深入学习 C++ 的各个方面。
多实践，多练习: 将所学知识应用到实际项目中，通过实践来巩固和提升技能。
阅读优秀的 C++ 代码: 学习其他开发者优秀的代码风格和设计模式。
积极参与 C++ 社区: 与其他开发者交流学习经验，互相帮助，共同进步。

## 3.2. 理解的角度
观察 (细节)  
看 (大局)  
感受 (发现规律)  
洞见 (点爆发)  
所谓理解就是要理解模式  

## 3.3. 问题理解层级
(1) 发现问题  
(2) 解决问题  
(3) 规避问题  
(4) 消灭问题  
(5) 创造问题  

## 3.4. 问题规避原则
(1) 设计上规避(例如: glog在设计上面使用多线程独立文件来规避单文件加锁问题)  
(2) 约定规避(例如: 约定使用int64放大若干倍数来替代浮点数)  
(3) 实现规避(例如: 在高性能要求的场景, 使用纯C的数据结构来替代复杂的C++数据结构)  
(4) 潜规则规避(例如: 利用平台语言或者数据结构的特性 来规避问题)  

## 3.5. 如何消灭问题
(1) 编码规范  
(2) 数据驱动开发  
(3) 代码生成技术  
(4) 为什么消灭了问题? 人是最不可控的, 减少了人本身对事物的影响.  

# 4. 编程感悟
程序的精髓在于数据结构的组织与控制.
稳定的需求是产品质量的基石.
真正的需求，潜藏在人性因素与其他一系列因素的相互关联之中.  